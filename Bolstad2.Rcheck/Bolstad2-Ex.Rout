
R version 4.1.1 (2021-08-10) -- "Kick Things"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "Bolstad2"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> base::assign(".ExTimings", "Bolstad2-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('Bolstad2')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("BayesLogistic")
> ### * BayesLogistic
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: BayesLogistic
> ### Title: Bayesian Logistic Regression
> ### Aliases: BayesLogistic
> 
> ### ** Examples
> 
> 
> data(logisticTest.df)
> BayesLogistic(logisticTest.df$y, logisticTest.df$x)
      N     mean     stdev      sterr       min       q1      med       q3
b0 1000 2.464804 0.5394504 0.01705892 0.9200852 2.118086 2.427517 2.789242
b1 1000 3.436776 0.6896585 0.02180892 1.6989244 2.971904 3.405307 3.867944
        max
b0 5.202219
b1 7.418097
   Mean.beta StdDev.beta   Z.beta
b0  2.464804   0.5394504 4.569103
b1  3.436776   0.6896585 4.983300
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("BayesLogistic", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("BayesPois")
> ### * BayesPois
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: BayesPois
> ### Title: Bayesian Pois Regression
> ### Aliases: BayesPois
> 
> ### ** Examples
> 
> 
> data(poissonTest.df)
> results <- BayesPois(poissonTest.df$y, poissonTest.df$x)
      N    mean       stdev        sterr      min       q1      med       q3
b0 1000 1.27388 0.014668716 0.0004638655 1.224895 1.264032 1.273896 1.284047
b1 1000 4.81695 0.007683344 0.0002429687 4.793636 4.811949 4.817066 4.822163
        max
b0 1.318505
b1 4.843878
   Mean.beta StdDev.beta    Z.beta
b0   1.27388 0.014668716  86.84331
b1   4.81695 0.007683344 626.93409
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("BayesPois", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("GelmanRubin")
> ### * GelmanRubin
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: GelmanRubin
> ### Title: Calculate the Gelman Rubin statistic
> ### Aliases: GelmanRubin GR
> 
> ### ** Examples
> 
> 
> ## take four chains sampling from a normal mixture density
> theta0 <- c(0,1)
> theta1 <- c(3,2)
> p <- 0.6
> candidate <- c(0, 3)
> 
> v1 <- normMixMH(theta0, theta1, p, candidate, steps = 200)
> v2 <- normMixMH(theta0, theta1, p, candidate, steps = 200)
> v3 <- normMixMH(theta0, theta1, p, candidate, steps = 200)
> v4 <- normMixMH(theta0, theta1, p, candidate, steps = 200)
> 
> theta<-cbind(v1,v2,v3,v4)
> GelmanRubin(theta)
1.01613200218879 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("GelmanRubin", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("bivnormMH")
> ### * bivnormMH
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: bivnormMH
> ### Title: Metropolis Hastings sampling from a Bivariate Normal
> ###   distribution
> ### Aliases: bivnormMH
> 
> ### ** Examples
> 
> 
> ## independent chain
> chain1.df<-bivnormMH(0.9)$targetSample
> 
> ## random walk chain
> chain2.df<-bivnormMH(0.9, type = 'r')$targetSample
> 
> 
> ## blockwise MH chain
> chain3.df<-bivnormMH(0.9, type = 'b')$targetSample
> 
> ## Gibbs sampling chain
> chain4.df<-bivnormMH(0.9, type = 'g')$targetSample
> 
> oldPar <- par(mfrow=c(2,2))
> plot(y ~ x, type = 'l', chain1.df, main = 'Independent')
> plot(y ~ x, type = 'l', chain2.df, main = 'Random Walk')
> plot(y ~ x, type = 'l', chain3.df, main = 'Blockwise')
> plot(y ~ x, type = 'l', chain4.df, main = 'Gibbs')
> par(oldPar)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("bivnormMH", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("credInt")
> ### * credInt
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: credInt
> ### Title: Calculate a credible interval from a numerically specified
> ###   posterior CDF or from a sample from the posterior
> ### Aliases: credInt
> 
> ### ** Examples
> 
> 
> ## commands for calculating a numerical posterior CDF.
> ## In this example, the likelihood is proportional to
> ## \eqn{\theta^{3/2}\times \exp(-\theta/4)} and a N(6, 9) prior is used.
> theta <- seq(from = 0.001, to = 40, by = 0.001)
> prior <- dnorm(theta,6,3)
> ppnLike <- theta^1.5*exp(-theta/4)
> ppnPost <- prior*ppnLike
> scaleFactor <- sintegral(theta, ppnPost)$int
> posterior <- ppnPost/scaleFactor
> cdf <- sintegral(theta, posterior)$y
> ci<-credInt(theta, cdf)
Credible interval is : (2.02114790458962,11.4246333371552)
> par(mfrow=c(2,2))
> plot(prior ~ theta, type = 'l',  main = 'Prior N(6, 9)')
> plot(ppnLike ~ theta, type = 'l', main = 'Proportional likelihood')
> plot(posterior ~ theta, type = 'l', main = 'Posterior')
> abline(v=c(unlist(ci)))
> 
> ## Use an inverse method to take a random sample of size 1000
> ## from the posterior
> suppressWarnings(Finv<-approxfun(cdf,theta))
> thetaSample<-Finv(runif(1000))
> ci<-credInt(thetaSample)
Credible interval is (2.19599058377201,11.4565973554413)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("credInt", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("credIntNum")
> ### * credIntNum
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: credIntNum
> ### Title: Calculate a credible interval from a numerically specified
> ###   posterior CDF
> ### Aliases: credIntNum
> 
> ### ** Examples
> 
> 
> ## commands for calculating a numerical posterior CDF.
> ## In this example, the likelihood is proportional to
> ## \eqn{\theta^{3/2}\times \exp(-\theta/4)} and a N(6, 9) prior is used.
> theta <- seq(from = 0.001, to = 40, by = 0.001)
> prior <- dnorm(theta,6,3)
> ppnLike <- theta^1.5*exp(-theta/4)
> ppnPost <- prior*ppnLike
> scaleFactor <- sintegral(theta, ppnPost)$int
> posterior <- ppnPost/scaleFactor
> cdf <- sintegral(theta, posterior)$y
> ci<-credIntNum(theta, cdf)
Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm) :
  collapsing to unique 'x' values
Credible interval is : (2.02114790458962,11.4246333371552)
> par(mfrow=c(2,2))
> plot(prior ~ theta, type = 'l',  main = 'Prior N(6, 9)')
> plot(ppnLike ~ theta, type = 'l', main = 'Proportional likelihood')
> plot(posterior ~ theta, type = 'l', main = 'Posterior')
> abline(v=c(unlist(ci)))
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("credIntNum", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("credIntSamp")
> ### * credIntSamp
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: credIntSamp
> ### Title: Calculate a credible interval from a numerically specified
> ###   posterior CDF
> ### Aliases: credIntSamp
> 
> ### ** Examples
> 
> 
> ## posterior is N(0,1)
> theta <- rnorm(1000)
> ci<-credIntSamp(theta)
Credible interval is (-2.13087353074678,2.00610929078564)
> plot(density(theta))
> abline(v=c(unlist(ci)))
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("credIntSamp", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("describe")
> ### * describe
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: describe
> ### Title: Give simple descriptive statistics for a matrix or a data frame
> ### Aliases: describe
> 
> ### ** Examples
> 
> 
> data(poissonTest.df)
> describe(poissonTest.df)
          N         mean        stdev        sterr           min          q1
x       100 1.308488e-01 8.850879e-01 8.850879e-02 -2.340585e+00 -0.41225937
eps     100 6.588806e-03 9.651264e-02 9.651264e-03 -1.816151e-01 -0.06713503
log.lam 100 1.660833e+00 4.429345e+00 4.429345e-01 -1.088454e+01 -1.17576279
lam     100 1.821149e+03 1.001592e+04 1.001592e+03  1.874584e-05  0.30880134
y       100 1.819610e+03 1.001553e+04 1.001553e+03  0.000000e+00  0.00000000
                med          q3          max
x       0.178115813  0.73628656 2.116507e+00
eps     0.004193399  0.07456499 2.715079e-01
log.lam 1.874461533  4.59006387 1.147421e+01
lam     6.517455763 98.61346806 9.620220e+04
y       7.000000000 92.50000000 9.622100e+04
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("describe", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("hierMeanReg")
> ### * hierMeanReg
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: hierMeanReg
> ### Title: Hierarchical Normal Means Regression Model
> ### Aliases: hierMeanReg
> 
> ### ** Examples
> 
> 
> priorTau <- list(tau0 = 0, v0 = 1000)
> priorPsi <- list(psi0 = 500, eta0 = 1)
> priorVar <- list(s0 = 500, kappa0 = 1)
> priorBeta <- list(b0 = c(0,0), bMat = matrix(c(1000,100,100,1000), ncol = 2))
> 
> data(hiermeanRegTest.df)
> data.df <- hiermeanRegTest.df
> design <- list(y = data.df$y, group = data.df$group,
+                x = as.matrix(data.df[,3:4]))
> r<-hierMeanReg(design, priorTau, priorPsi, priorVar, priorBeta)
           N         mean        stdev        sterr         min           q1
tau     1000 1.693951e+01 3.435547e+01    1.0864154 -104.224136    -6.668654
psi     1000 1.117038e+05 3.054536e+05 9659.2900911    1.562948 35122.218101
mu.1    1000 2.716263e+02 3.385074e+01    1.0704543   40.893279   252.402905
mu.2    1000 2.771190e+02 3.329747e+01    1.0529585   45.332392   259.568920
mu.3    1000 2.811215e+02 3.313606e+01    1.0478544   49.581346   264.306807
beta.1  1000 5.459111e+00 3.948087e+00    0.1248495  -19.810209     2.960954
beta.2  1000 3.851820e+00 7.947875e+00    0.2513339  -21.949735    -1.410971
sigmaSq 1000 2.489663e+03 8.964236e+02   28.3474027  991.129298  1938.271322
sigma   1000 4.924687e+01 8.029577e+00    0.2539175   31.482206    44.025803
                 med           q3          max
tau        16.161659 4.180125e+01 1.078471e+02
psi     63580.879986 1.090902e+05 7.886651e+06
mu.1      274.707423 2.926134e+02 3.706966e+02
mu.2      279.166989 2.979246e+02 3.739071e+02
mu.3      284.806197 3.017289e+02 3.589779e+02
beta.1      5.289063 7.914029e+00 2.316352e+01
beta.2      3.640776 9.099893e+00 3.659364e+01
sigmaSq  2318.313874 2.819336e+03 1.075269e+04
sigma      48.148864 5.309741e+01 1.036952e+02
> 
> oldPar <- par(mfrow = c(3,3))
> plot(density(r$tau))
> plot(density(r$psi))
> plot(density(r$mu.1))
> plot(density(r$mu.2))
> plot(density(r$mu.3))
> plot(density(r$beta.1))
> plot(density(r$beta.2))
> plot(density(r$sigmaSq))
> par(oldPar)
> 
> ## example with no covariates
> priorTau <- list(tau0 = 0, v0 = 1000)
> priorPsi <- list(psi0 = 500, eta0 = 1)
> priorVar <- list(s0 = 500, kappa0 = 1)
> 
> data(hiermeanRegTest.df)
> data.df <- hiermeanRegTest.df
> design <- list(y = data.df$y, group = data.df$group, x = NULL)
> r<-hierMeanReg(design, priorTau, priorPsi, priorVar)
           N         mean        stdev        sterr        min           q1
tau     1000     13.64003     31.50316    0.9962175 -78.342598    -7.975333
psi     1000 128233.72635 147889.65131 4676.6814051   1.093019 51467.435840
mu.1    1000    311.72075     32.38059    1.0239642 -28.590972   303.418577
mu.2    1000    315.75183     31.85133    1.0072275 -26.369468   308.882042
mu.3    1000    321.24427     32.63284    1.0319411 -28.556158   313.946774
sigmaSq 1000   3138.38115   7356.39279  232.6295659  57.730047  1945.659628
sigma   1000     51.15988     22.83789    0.7221975   7.598029    44.109631
                med           q3          max
tau        13.63909     35.43243     124.2279
psi     83215.09359 143456.03607 1584975.9213
mu.1      314.47540    325.66223     361.3020
mu.2      318.73356    328.41842     381.9615
mu.3      323.89689    334.23414     374.2266
sigmaSq  2340.16752   2814.83245  115049.5580
sigma      48.37528     53.05499     339.1896
> 
> oldPar <- par(mfrow = c(3,2))
> plot(density(r$tau))
> plot(density(r$psi))
> plot(density(r$mu.1))
> plot(density(r$mu.2))
> plot(density(r$mu.3))
> plot(density(r$sigmaSq))
> par(oldPar)
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("hierMeanReg", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("normGibbs")
> ### * normGibbs
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: normGibbs
> ### Title: Draw a sample from a posterior distribution of data with an
> ###   unknown mean and variance using Gibbs sampling
> ### Aliases: normGibbs
> 
> ### ** Examples
> 
> 
> ## firstly generate some random data
> mu <- rnorm(1)
> sigma <- rgamma(1,5,1)
> y <- rnorm(100, mu, sigma)
> 
> ## A \eqn{N(10,3^2)} prior for \eqn{\mu} and a 25 times inverse chi-squared
> ## with one degree of freedom prior for \eqn{\sigma^2}
> MCMCSampleInd <- normGibbs(y, steps = 5000, priorMu = c(10,3),
+                            priorVar = c(25,1))
       N       mean     stdev       sterr       min          q1        med
mu  5000  0.1893475 0.4332710 0.006127377 -1.731530 -0.09779162  0.1930645
sig 5000  4.4438013 0.3220448 0.004554402  3.512251  4.21782626  4.4293573
var 5000 19.8510619 2.9161242 0.041240225 12.335906 17.79005838 19.6192062
            q3       max
mu   0.4784958  1.713670
sig  4.6395274  7.073313
var 21.5252146 50.031755
> 
> 
> ## We can also use a joint conjugate prior for \eqn{\mu} and \eqn{\sigma^2}.
> ## This will be a \emph{normal}\eqn{(m,\sigma^2/n_0)} prior for \eqn{\mu} given
> ## the variance \eqn{\sigma^2}, and an \eqn{s0} times an \emph{inverse
> ## chi-squared} prior for \eqn{\sigma^2}.
> MCMCSampleJoint <- normGibbs(y, steps = 5000, type = 'joint',
+                              priorMu = c(10,3), priorVar = c(25,1))
       N       mean     stdev       sterr       min         q1        med
mu  5000  0.1900903 0.4387757 0.006205226 -1.600871 -0.1027658  0.1926053
sig 5000  4.4496870 0.3280200 0.004638904  3.482116  4.2188269  4.4326565
var 5000 19.9072897 3.0053420 0.042501954 12.125133 17.7985008 19.6484440
            q3       max
mu   0.4855801  1.737934
sig  4.6515858  8.445765
var 21.6372502 71.330940
> 
> ## Now plot the results
> oldPar <- par(mfrow=c(2,2))
> 
> plot(density(MCMCSampleInd$mu),xlab=expression(mu), main =
+ 'Independent')
> abline(v=mu)
> plot(density(MCMCSampleInd$sig),xlab=expression(sig), main =
+ 'Independent')
> abline(v=sigma)
> 
> plot(density(MCMCSampleJoint$mu),xlab=expression(mu), main =
+ 'Joint')
> abline(v=mu)
> plot(density(MCMCSampleJoint$sig),xlab=expression(sig), main =
+ 'Joint')
> abline(v=sigma)
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("normGibbs", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("normMixMH")
> ### * normMixMH
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: normMixMH
> ### Title: Sample from a normal mixture model using Metropolis-Hastings
> ### Aliases: normMixMH
> 
> ### ** Examples
> 
> 
> ## Set up the normal mixture
> theta0 <- c(0,1)
> theta1 <- c(3,2)
> p <- 0.8
> 
> ## Sample from an independent N(0,3^2) candidate density
> candidate <- c(0, 3)
> MCMCsampleInd <- normMixMH(theta0, theta1, p, candidate)
> 
> 
> ## If we wish to use the alternative random walk N(0, 0.5^2)
> ## candidate density
> candidate <- c(0, 0.5)
> MCMCsampleRW <- normMixMH(theta0, theta1, p, candidate, type = 'rw')
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("normMixMH", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("pNull")
> ### * pNull
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pNull
> ### Title: Test a one sided hypothesis from a numerically specified
> ###   posterior CDF or from a sample from the posterior
> ### Aliases: pNull
> 
> ### ** Examples
> 
> 
> ## commands for calculating a numerical posterior CDF.
> ## In this example, the likelihood is proportional to
> ## \eqn{\theta^{3/2}\times \exp(-\theta/4)} and a N(6, 9) prior is used.
> theta <- seq(from = 0.001, to = 40, by = 0.001)
> prior <- dnorm(theta,6,3)
> ppnLike <- theta^1.5*exp(-theta/4)
> ppnPost <- prior*ppnLike
> scaleFactor <- sintegral(theta, ppnPost)$int
> posterior <- ppnPost/scaleFactor
> cdf <- sintegral(theta, posterior)$y
> pNull(15, theta, cdf)
Posterior Pr(theta>=theta0) is 0.000600230409672609
> 
> ## Use an inverse method to take a random sample of size 1000
> ## from the posterior
> suppressWarnings(Finv <- approxfun(cdf, theta))
> thetaSample<-Finv(runif(1000))
> pNull(15, thetaSample)
Posterior Pr(theta>=theta0) is 0.002
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pNull", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("pnullNum")
> ### * pnullNum
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pnullNum
> ### Title: Test a one sided hypothesis from a numerically specified
> ###   posterior CDF
> ### Aliases: pnullNum
> 
> ### ** Examples
> 
> 
> ## commands for calculating a numerical posterior CDF.
> ## In this example, the likelihood is proportional to
> ## \eqn{\theta^{3/2}\times \exp(-\theta/4)} and a N(6, 9) prior is used.
> theta <- seq(from = 0.001, to = 40, by = 0.001)
> prior <- dnorm(theta,6,3)
> ppnLike <- theta^1.5*exp(-theta/4)
> ppnPost <- prior*ppnLike
> scaleFactor <- sintegral(theta, ppnPost)$int
> posterior <- ppnPost/scaleFactor
> cdf <- sintegral(theta, posterior)$y
> pnullNum(1, theta, cdf)
Posterior Pr(theta>=theta0) is 0.00348437219948438
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pnullNum", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("pnullSamp")
> ### * pnullSamp
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pnullSamp
> ### Title: Test a one sided hypothesis using a sample from a posterior
> ###   density
> ### Aliases: pnullSamp
> 
> ### ** Examples
> 
> 
> ## The posterior density is N(3,1)
> theta <- rnorm(1000,3)
> 
> ## test whether the true mean is greater than 0 (it is obviously!)
> pnullSamp(theta)
Posterior Pr(theta>=theta0) is 0.001
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pnullSamp", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("sintegral")
> ### * sintegral
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: sintegral
> ### Title: Numerical integration using Simpson's Rule
> ### Aliases: sintegral
> ### Keywords: misc
> 
> ### ** Examples
> 
> 
> ## integrate the normal density from -3 to 3
> x<-seq(-3,3,length=100)
> fx<-dnorm(x)
> estimate<-sintegral(x,fx)$int
> true.val<-diff(pnorm(c(-3,3)))
> cat(paste('Absolute error :',round(abs(estimate-true.val),7),'\n'))
Absolute error : 8.1e-06 
> cat(paste('Relative percentage error :', 100*round((abs(estimate-true.val)/true.val),6),'%\n'))
Relative percentage error : 8e-04 %
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("sintegral", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("thin")
> ### * thin
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: thin
> ### Title: Thin an MCMC sample
> ### Aliases: thin
> 
> ### ** Examples
> 
> 
> ## A blockwise Metropolis-Hastings chain of 1000 elements, thinned to
> ## 5th element
> ##
> 
> MCMCSampleBW <- bivnormMH(0.9, type = 'block')
> MCMCSampleBW <- thin(MCMCSampleBW, 5)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("thin", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  3.44 0.11 3.65 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
